using Docfx.Plugins;
using System.Collections.Immutable;
using System.Composition;
using Docfx.Build.ManagedReference;
using Docfx.Common;
using Docfx.DataContracts.ManagedReference;
using Docfx.DataContracts.Common;
using System.Reflection;
using System.Text.RegularExpressions;

namespace VintageStoryDocFXPlugin
{
    /// <summary>
    /// This is a custom implementation of the ManagedReferenceDocumentProcessor.
    /// It is designed to completely takeover the functionality of the document processor, and provide the functionality to edit page through C# code.
    /// On it's own, this alters nothing. Additional 'addon' plugins should be created which consist of a <see cref="VSProcessorAddon"/> class for real functionality.
    /// </summary>
    [Export(typeof(IDocumentProcessor))]
    public class VSDocumentProcessor : ManagedReferenceDocumentProcessor
    {
    
        #region Fields
        //I don't really know what these do lol but they have to be registered in the metadata with the YAML files.
        private static readonly string[] SystemKeys = [
            "uid",
        "isEii",
        "isExtensionMethod",
        "parent",
        "children",
        "href",
        "langs",
        "name",
        "nameWithType",
        "fullName",
        "type",
        "source",
        "documentation",
        "assemblies",
        "namespace",
        "summary",
        "remarks",
        "example",
        "syntax",
        "overridden",
        "overload",
        "exceptions",
        "seealso",
        "see",
        "inheritance",
        "derivedClasses",
        "level",
        "implements",
        "inheritedMembers",
        "extensionMethods",
        "conceptual",
        "platform",
        "attributes",
        Constants.PropertyName.AdditionalNotes
        ];
        #endregion

        public override string Name => nameof(VSDocumentProcessor);

        static List<VSProcessorAddon> Addons = null;

        public VSDocumentProcessor()
        {}

        /// <summary>
        /// Will register a processor addon for functionality.
        /// This is done automatically by the <see cref="VSProcessorAddon"/> base class.
        /// </summary>
        /// <param name="addon"></param>
        public static void RegisterProcessorAddon(VSProcessorAddon addon)
        {
            if (Addons == null) Addons = new List<VSProcessorAddon>();
            Addons.Add(addon);
        }

        /// <summary>
        /// We need to ensure that our document processor is actually used instead of the default one - But only if the default one would have been used.
        /// </summary>
        public override ProcessingPriority GetProcessingPriority(FileAndType file)
        {
            ProcessingPriority baseProcessing = base.GetProcessingPriority(file);
            if (baseProcessing == ProcessingPriority.Normal) return ProcessingPriority.High;
            else if (baseProcessing == ProcessingPriority.BelowNormal) return ProcessingPriority.AboveNormal;
            return baseProcessing;
        }

        /// <summary>
        /// This function gets called for every yml file that has been generated by docfx.
        /// Its purpose is to return a FileModel from said yml file, so we can hook onto this function to make edits.
        /// MUch of this is actually copied from the inherited class. (<see cref="ManagedReferenceDocumentProcessor"/>)
        /// </summary>
        protected override FileModel LoadArticle(FileAndType file, ImmutableDictionary<string, object> metadata)
        {
            //Default logic; not sure how needed this section is really...
            if (YamlMime.ReadMime(file.File) == null)
            {
                Logger.LogWarning(
                    "Please add `YamlMime` as the first line of file, e.g.: `### YamlMime:ManagedReference`, otherwise the file will be not treated as ManagedReference source file in near future.",
                    file: file.File,
                    code: WarningCodes.Yaml.MissingYamlMime);
            }

            //To be able to edit the required elements, we deserialize this into a page view model.
            var page = YamlUtility.Deserialize<PageViewModel>(file.File);
            if (page?.Items == null || page.Items.Count == 0)
            {
                return null;
            }

            //Now, iterate through all the appropriate addons. These will change the appearance of the page view model.
            foreach (VSProcessorAddon addon in Addons)
            {
                addon.OnPageBeingProcessed(page);
            }

            //Anywhere below this is the default logic in the metadata base function. 
            if (page.Metadata == null)
            {
                page.Metadata = metadata.ToDictionary(p => p.Key, p => p.Value);
            }
            else
            {
                foreach (var (key, value) in metadata.OrderBy(item => item.Key))
                {
                    page.Metadata[key] = value;
                }
            }
            page.Metadata[Constants.PropertyName.SystemKeys] = SystemKeys;

            var localPathFromRoot = PathUtility.MakeRelativePath(EnvironmentContext.BaseDirectory, EnvironmentContext.FileAbstractLayer.GetPhysicalPath(file.File));

            return new FileModel(file, page)
            {
                Uids = (from item in page.Items select item.Uid)
                .Concat(from item in page.Items where item.Overload != null select item.Overload)
                .Distinct().Select(s => new UidDefinition(s, localPathFromRoot)).ToImmutableArray(),
                LocalPathFromRoot = localPathFromRoot
            };
        }        
    }
}
